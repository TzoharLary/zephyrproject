# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2025 Texas Instruments Incorporated - https://www.ti.com/
#-------------------------------------------------------------------------------
# This is a common configuration and procedure definitions for LPF3 devices. This
# file contains common variables, SACI commands, utility functions used across
# CC23xx and CC27xx device scripts. It centralizes the common functionality to
# ensure consistency and ease of maintenance across all related configuration
# scripts.
# Any LPF3 device-specific settings should be defined in the respective device
# script, while reusable logic remains in this file.
#-------------------------------------------------------------------------------

# Device blank check result macros
set DEVICE_BLANK 1
set DEVICE_NOT_BLANK 0
# Sleep time duration macros
set SHORT_SLEEP_MS  5
set MEDIUM_SLEEP_MS 60
set LONG_SLEEP_MS   100
# Boot status (Boot entered SACI)
set BOOT_ENTERED_SACI 0x20
# Wait time for data ready in RXD register
set SACI_RXD_READY_CHECK_TIMEOUT 3000
# SACI commands
set SACI_CMD_FLASH_PROG_CCFG_SECTOR         0x1000c
set SACI_CMD_FLASH_VERIFY_CCFG_SECTOR_BLANK 0x80000011
set SACI_CMD_FLASH_ERASE_CHIP               0x09
set SACI_CMD_FLASH_VERIFY_CCFG_SECTOR_CRC   0x00030011
set SACI_CMD_FLASH_PROG_SCFG_SECTOR         0x0400001a
set SACI_CMD_FLASH_VERIFY_SCFG_SECTOR       0x0001001b
# Permission section parameters for CCFG and SCFG
set ccfg_permission_section_start_idx 0x10
set ccfg_permission_idx               0x18
set ccfg_permission_cfg_len           0x73c
set ccfg_permission_crc_idx           0x74c
set scfg_permission_section_start_idx 0x0
set scfg_permission_idx               0xd0
set scfg_permission_cfg_len           0xe4
set scfg_permission_crc_idx           0xe4
# Debug configuration related parameters
set dbg_cfg_len     0x2c
set dbg_cfg_idx     0x7d0
set dbg_cfg_crc_idx 0x7fc

# Helper function to get minimum of two values
proc min {a b} {
    if {$a < $b} {
        return $a
    } else {
        return $b
    }
}

# Helper function to prepend a new element to an existing list
proc prepend { arr txt } {
	set arr_new "${txt}${arr}"
	return $arr_new
}

proc calculate_crc {data_bytes length} {
    # Initialize accumulator with 0xFFFFFFFF
    set acc 0xFFFFFFFF
    # Define the CRC lookup table (same as in C version)
    set crc_rand32_lut {
        0x00000000 0x1DB71064 0x3B6E20C8 0x26D930AC
        0x76DC4190 0x6B6B51F4 0x4DB26158 0x5005713C
        0xEDB88320 0xF00F9344 0xD6D6A3E8 0xCB61B38C
        0x9B64C2B0 0x86D3D2D4 0xA00AE278 0xBDBDF21C
    }
    # Check if data is provided
    if {[llength $data_bytes] > 0} {
        # Process each byte
        for {set i 0} {$i < $length} {incr i} {
            # Get the current byte value (should be an integer 0-255)
            set data [lindex $data_bytes $i]

            # Process lower 4 bits
            set index [expr {($acc & 0x0F) ^ ($data & 0x0F)}]
            set acc [expr {($acc >> 4) ^ [lindex $crc_rand32_lut $index]}]

            # Process upper 4 bits
            set index [expr {($acc & 0x0F) ^ ($data >> 4)}]
            set acc [expr {($acc >> 4) ^ [lindex $crc_rand32_lut $index]}]
        }
    }
    # Final XOR with 0xFFFFFFFF
    return [expr {$acc ^ 0xFFFFFFFF}]
}

# Function to extract CCFG section using objdump
proc extract_ccfg_with_objdump {binary_file} {
    if {[catch {exec objdump -s -j .ccfg $binary_file} result]} {
        return ""
    }
    return $result
}

# Function to extract SCFG section using objdump
proc extract_scfg_with_objdump {binary_file} {
    if {[catch {exec objdump -s -j .scfg $binary_file} result]} {
        return ""
    }
    return $result
}

# Function to parse objdump output and extract binary data
proc parse_objdump_output {output} {
    set ccfg_data [list]
    set in_ccfg_section 0
    foreach line [split $output "\n"] {
        # Check if we're in the CCFG section content
        if {[regexp {Contents of section \.ccfg:} $line]} {
            set in_ccfg_section 1
            continue
        }
        if {$in_ccfg_section && [regexp {^\s+[0-9a-f]+ ([0-9a-f ]{2,})\s+.*$} $line -> hex_str]} {
            # Remove spaces from hex string
            set hex_str [string map {" " ""} $hex_str]
            # Convert each pair of hex digits to a byte
            for {set i 0} {$i < [string length $hex_str]} {incr i 2} {
                if {$i+1 < [string length $hex_str]} {
                    set byte_hex [string range $hex_str $i [expr {$i + 1}]]
                    lappend ccfg_data [expr 0x$byte_hex]
                }
            }
        }
    }
    return $ccfg_data
}

# Function to parse objdump output and extract binary data
proc parse_scfg_objdump_output {output} {
    set scfg_data [list]
    set in_scfg_section 0
    foreach line [split $output "\n"] {
        # Check if we're in the CCFG section content
        if {[regexp {Contents of section \.scfg:} $line]} {
            set in_scfg_section 1
            continue
        }
        if {$in_scfg_section && [regexp {^\s+[0-9a-f]+ ([0-9a-f ]{2,})\s+.*$} $line -> hex_str]} {
            # Remove spaces from hex string
            set hex_str [string map {" " ""} $hex_str]
            # Convert each pair of hex digits to a byte
            for {set i 0} {$i < [string length $hex_str]} {incr i 2} {
                if {$i+1 < [string length $hex_str]} {
                    set byte_hex [string range $hex_str $i [expr {$i + 1}]]
                    lappend scfg_data [expr 0x$byte_hex]
                }
            }
        }
    }
    return $scfg_data
}

# Converts the byte data into 32 bit hex format
proc get_data_hex_format {data} {
	set data_hex [list]
	set index 0
	for {set i 0} {$i < [llength $data]} {incr i 4} {
		set chunk_end [min [expr {$i + 3}] [expr {[llength $data] - 1}]]
		set chunk [lrange $data $i $chunk_end]
		# Format hex line
		set hex_line ""
		foreach byte $chunk {
			set hex_line [ prepend $hex_line [format "%02x" $byte] ]
		}
		lappend data_hex [format "0x%08X" [expr 0x$hex_line]]
		incr index 1
	}
	return $data_hex
}

# This function will perform device reset and halt the CPU at first break point
proc perform_reset_halt { device } {
	global SHORT_SLEEP_MS MEDIUM_SLEEP_MS LONG_SLEEP_MS
	adapter assert srst
	# drop sRST Pin after at least for few ms
	sleep $SHORT_SLEEP_MS
	adapter deassert srst
	# Wait for stabilization
	sleep $MEDIUM_SLEEP_MS
	dap init
	# Wait for the device to enter SACI mode
	sleep $LONG_SLEEP_MS
	if { [$device reset_halt 0] eq 0 } {
		poll
		halt 0
		wait_halt
	} else {
		return -code error "Error: Failed to reset and halt the device"
	}
}

# Sends verify CCFG SACI command to identify the device is blank or not.
proc check_device_blank {chip_dap } {
	global DEVICE_BLANK DEVICE_NOT_BLANK SHORT_SLEEP_MS MEDIUM_SLEEP_MS LONG_SLEEP_MS BOOT_ENTERED_SACI SACI_CMD_FLASH_VERIFY_CCFG_SECTOR_BLANK
	set device_status [$chip_dap apreg 1 0xc]
	set extracted [expr {($device_status >> 8) & 0xFF}]
	set boot_status [format "0x%02x" $extracted]
	if { [expr $boot_status] != $BOOT_ENTERED_SACI } {
		# Reset the device
		adapter assert srst
		# drop sRST Pin after at least for few ms
		sleep $SHORT_SLEEP_MS
		adapter deassert srst
		# Wait for stabilization
		sleep $MEDIUM_SLEEP_MS
		dap init
	}
	# CCFG Blank check
    set crc_lst {0x0 0x0 0x0 0x0}
	set rxd [execute_saci_command $SACI_CMD_FLASH_VERIFY_CCFG_SECTOR_BLANK $crc_lst $chip_dap]
	# If first 8 bits of RXD are command id
	set resp_cmd_id [expr {$rxd & 0xff}]
	set resp_result [expr {($rxd >> 16) & 0xff}]
	set ccfg_empty [expr {([expr $resp_cmd_id] == [expr {$SACI_CMD_FLASH_VERIFY_CCFG_SECTOR_BLANK & 0xff}]) && ([expr $resp_result] == 0)}]
	if { $ccfg_empty } {
		return $DEVICE_BLANK
	} else {
		return $DEVICE_NOT_BLANK
	}
}

proc perform_chip_erase {chip_dap} {
	global DEVICE_BLANK DEVICE_NOT_BLANK SHORT_SLEEP_MS MEDIUM_SLEEP_MS \
		LONG_SLEEP_MS BOOT_ENTERED_SACI SACI_CMD_FLASH_ERASE_CHIP
	set device_status [$chip_dap apreg 1 0xc]
	set extracted [expr {($device_status >> 8) & 0xFF}]
	set boot_status [format "0x%02x" $extracted]
	if { [expr $boot_status] != $BOOT_ENTERED_SACI } {
		# Reset the device
		adapter assert srst
		# drop sRST Pin after at least for few ms
		sleep $SHORT_SLEEP_MS
		adapter deassert srst
		# Wait for stabilization
		sleep $MEDIUM_SLEEP_MS
		dap init
		# Wait for the device to enter SACI mode
		sleep $LONG_SLEEP_MS
	}
	# Executing chip erase SACI command
	set res [ execute_saci_command $SACI_CMD_FLASH_ERASE_CHIP 0xB7E3A08F $chip_dap]
}

# This function creates the CRC list for CCFG data in order to verify CCFG content.
proc create_calculated_crc_list {ccfg_data} {
    # CCFG CRC parameters
	set BOOT_CCFG_LEN [expr {0x0c}]
	set CENTRAL_CCFG_LEN [expr {0x73c}]
	set DEBUG_CCFG_LEN [expr {0x2c}]

	set BOOT_CCFG_START_IDX 0x0
	set CENTRAL_CCFG_START_IDX [expr {0x10}]
	set DEBUG_CCFG_START_IDX [expr {0x7d0}]

	# Creating data bytes required for calculating CRCs
	set boot_ccfg_data [lrange $ccfg_data $BOOT_CCFG_START_IDX \
		[expr {$BOOT_CCFG_START_IDX + $BOOT_CCFG_LEN - 1}]]
	set central_ccfg_data [lrange $ccfg_data $CENTRAL_CCFG_START_IDX \
		[expr {$CENTRAL_CCFG_START_IDX + $CENTRAL_CCFG_LEN - 1}]]
	set debug_ccfg_data [lrange $ccfg_data $DEBUG_CCFG_START_IDX \
		[expr {$DEBUG_CCFG_START_IDX + $DEBUG_CCFG_LEN - 1}]]

	# Calculating CRCs
	set boot_crc [format "0x%08X" [calculate_crc $boot_ccfg_data $BOOT_CCFG_LEN] ]
	set central_crc [format "0x%08X" [calculate_crc $central_ccfg_data $CENTRAL_CCFG_LEN] ]
	# Since we are skipping user record part
	set user_rec_crc 0x0
	set debug_crc [format "0x%08X" [calculate_crc $debug_ccfg_data $DEBUG_CCFG_LEN] ]

	set crc_lst [list $boot_crc $central_crc $user_rec_crc $debug_crc]

    return $crc_lst
}

# Blank device handler, this function will handle necessary steps if the device is blank
proc handle_blank_device { ccfg_data crc_lst chip_dap chip_name scfg_data scfg_crc } {
	global DEVICE_BLANK DEVICE_NOT_BLANK BOOT_ENTERED_SACI SACI_CMD_FLASH_PROG_CCFG_SECTOR \
		SACI_CMD_FLASH_VERIFY_CCFG_SECTOR_CRC SACI_CMD_FLASH_PROG_SCFG_SECTOR \
		SACI_CMD_FLASH_VERIFY_SCFG_SECTOR
	set device_status [$chip_dap apreg 1 0xc]
	# Since bit 8-15 are the boot status
	set extracted [expr {($device_status >> 8) & 0xFF}]
	set boot_status [format "0x%02x" $extracted]
	if { [expr $boot_status] != $BOOT_ENTERED_SACI } {
		# Reset the device
		adapter assert srst
		# drop sRST Pin after at least for few ms
		sleep $SHORT_SLEEP_MS
		adapter deassert srst
		# Wait for stabilization
		sleep $MEDIUM_SLEEP_MS
		dap init
		# Wait for the device to enter SACI mode
		sleep $LONG_SLEEP_MS
	}
	set cmd_params [linsert $ccfg_data 0 0xB7E3A08F]
	set ret_val [ execute_saci_command $SACI_CMD_FLASH_PROG_CCFG_SECTOR $cmd_params $chip_dap]
	# Check if CCFG is empty (SACI command value 0x11)
	# Parameter word 1 - expBootCfgCrc32: Expected CRC32 of the boot configuration part
	# Parameter word 2 - expCentralCrc32: Expected CRC32 of the central part
	# Parameter word 3 - expUserRecCrc32: Expected CRC32 of the user record part
	# Parameter word 4 - expDebugCfgCrc32: Expected CRC32 of the debug configuration part
	set rxd [ execute_saci_command $SACI_CMD_FLASH_VERIFY_CCFG_SECTOR_CRC $crc_lst $chip_dap ]
    if { $chip_name == "cc27xx"} {
        set cmd_params [linsert $scfg_data 0 0xB7E3A08F]
        execute_saci_command $SACI_CMD_FLASH_PROG_SCFG_SECTOR $cmd_params $chip_dap
        execute_saci_command $SACI_CMD_FLASH_VERIFY_SCFG_SECTOR $scfg_crc $chip_dap
    }
	perform_reset_halt $chip_name
}

# Function for wait before accessing the RXD register for reading the command response
proc wait_rx_data_ready {chip_dap} {
	global SACI_RXD_READY_CHECK_TIMEOUT
	set total_sleep $SACI_RXD_READY_CHECK_TIMEOUT
	set check_interval [expr {$total_sleep / 10}]
	set rxctl [$chip_dap apreg 2 0xc]
	while { [expr {($rxctl & 0x1) != 0x1 && $total_sleep > 0}] } {
		incr total_sleep [expr -$check_interval]
		sleep $check_interval
		set rxctl [$chip_dap apreg 2 0xc]
	}
	if {[expr {$rxctl & 0x1}] != 0x1 } {
		return 0
	}
	return 1
}

proc execute_saci_command {command args chip_dap} {
	set clean_data [string trim $args "{}"]
	set arg_list [split $clean_data]
	# Set bit 1 of TXCTL (0x204): CMD_START
	# Indicates that TXD contains the first word of a command
	$chip_dap apreg 2 0x4 0x2
	# Set TXD (0x200)
	$chip_dap apreg 2 0x0 $command
	# Clear TXCTL (0x204)
	$chip_dap apreg 2 0x4 0x0
	# Write additional parameter words
	foreach {param_word} $arg_list {
		$chip_dap apreg 2 0x0 $param_word
	}
	wait_rx_data_ready $chip_dap
	# Read RXD (0x208) (to retrieve the response, if relevant)
	set rxd [$chip_dap apreg 2 0x8]
	return $rxd
}

# Function for checking permissions and handle not allowed permissions
proc handle_permissions_in_ccfg_or_scfg {data actual_permission_idx permission_section_start_idx permisson_cfg_len permission_crc_idx permission_type} {
	set permissions_allowed        0xaa
	set permissions_change         0
	set dbg_permission_allowed     0x5a
	set dbg_permission_not_allowed 0xa5
	# Extracting permission fields from data
	# allowReturnToFactory[3:0], allowFakeStby[7:4], allowToolsClientMode[11:8],
	# allowChipErase[15:12], allowFlashProgram[19:16], allowFlashVerify[23:20],
	# allowEnergyTrace[27:24], allowDebugPort[31:28]
	set permissions_byte0 [lindex $data $actual_permission_idx]
	set permissions_byte1 [lindex $data [expr {$actual_permission_idx + 1 }]]
	set permissions_byte2 [lindex $data [expr {$actual_permission_idx + 2 }]]
	set permissions_byte3 [lindex $data [expr {$actual_permission_idx + 3 }]]
	if { [expr {($permission_type != "debug") && ($permissions_byte0 != $permissions_allowed)}] } {
		lset data $actual_permission_idx [expr $permissions_allowed]
		set permissions_change 1
	}
	if { [expr {($permission_type != "debug") && ($permissions_byte1 != $permissions_allowed)}] } {
		lset data [expr {$actual_permission_idx + 1} ] [expr $permissions_allowed]
		set permissions_change 1
	}
	if { [expr {($permission_type != "debug") && ($permissions_byte2 != $permissions_allowed)}] } {
		lset data [expr {$actual_permission_idx + 2} ] [expr $permissions_allowed]
		set permissions_change 1
	}
	if { [expr {($permission_type != "debug") && ($permissions_byte3 != $permissions_allowed)}] } {
		lset data [expr {$actual_permission_idx + 3} ] [expr $permissions_allowed]
		set permissions_change 1
	}
	if {$permission_type == "debug"} {
		set dbg_auth_value [lindex $data $actual_permission_idx]
		if {$dbg_auth_value == $dbg_permission_not_allowed} {
			lset data $actual_permission_idx [expr $dbg_permission_allowed]
			set permissions_change 1
		}
	}
	if { $permissions_change} {
		set permissions_cfg_data [lrange $data $permission_section_start_idx \
			[expr {$permission_section_start_idx + $permisson_cfg_len - 1}]]
		set permissions_crc [calculate_crc $permissions_cfg_data $permisson_cfg_len]
		# Updating new permission section CRC in CCFG
		lset data $permission_crc_idx [expr {$permissions_crc & 0x000000ff}]
		lset data [expr {$permission_crc_idx + 1}] [expr {($permissions_crc>>8) & 0x000000ff}]
		lset data [expr {$permission_crc_idx + 2}] [expr {($permissions_crc>>16) & 0x000000ff}]
		lset data [expr {$permission_crc_idx + 3}] [expr {($permissions_crc>>24) & 0x000000ff}]
	}
	return $data
}

# Common examine-start event procedure for both cc23xx and cc27xx
proc configure_examine_start_event {target_name chip_name} {
    global DEVICE_BLANK
    # Store the parameters in global variables so they're accessible inside the event handler
    set ::_TARGET_NAME_TEMP $target_name
    set ::_CHIP_NAME_TEMP $chip_name
    $target_name configure -event examine-start {
		global ccfg_permission_section_start_idx ccfg_permission_idx ccfg_permission_cfg_len \
			ccfg_permission_crc_idx scfg_permission_section_start_idx scfg_permission_idx \
			scfg_permission_cfg_len scfg_permission_crc_idx dbg_cfg_idx dbg_cfg_crc_idx dbg_cfg_len
        set blank_check_res [check_device_blank $::_CHIP_NAME_TEMP.dap]
        if { $blank_check_res == $DEVICE_BLANK } {
            # Getting executable file path from the global variable if it exists
            set binary_file_path ""
            if { [info exists EXECUTABLE] } {
                set binary_file_path $EXECUTABLE
            } else {
                return -code error "Error: Couldn't find executable file path"
            }
            # Extract CCFG data
            set objdump_output [extract_ccfg_with_objdump $binary_file_path]
            if {$objdump_output == ""} {
                return -code error "Error: Failed to extract CCFG data from $binary_file_path"
            }
            set ccfg_data [parse_objdump_output $objdump_output]
			if { [llength $ccfg_data] == 0 } {
				return -code error "Error: Failed to parse CCFG data"
			}
            # Checking debug authorization required or not
			set ccfg_data [handle_permissions_in_ccfg_or_scfg $ccfg_data $dbg_cfg_idx \
				$dbg_cfg_idx $dbg_cfg_len $dbg_cfg_crc_idx "debug"]
			# Checking permissions in CCFG regarding flash operations
			set ccfg_data [handle_permissions_in_ccfg_or_scfg $ccfg_data $ccfg_permission_idx \
				$ccfg_permission_section_start_idx $ccfg_permission_cfg_len $ccfg_permission_crc_idx "flash"]
            # Creating CCFG CRC list
            set ccfg_crc_lst [create_calculated_crc_list $ccfg_data]
            set ccfg_data_hex [get_data_hex_format $ccfg_data]
            # Handle SCFG data for cc27xx only
            if { $::_CHIP_NAME_TEMP == "cc27xx" } {
                # Extract SCFG data
                set scfg_objdump_output [extract_scfg_with_objdump $binary_file_path]
                if {$scfg_objdump_output == ""} {
                    return -code error "Error: Failed to extract SCFG data from $binary_file_path"
                }
                set scfg_data [parse_scfg_objdump_output $scfg_objdump_output]
				if { [llength $scfg_data] == 0} {
					return -code error "Error: Failed to parse SCFG data"
				}
				# Checking permissions in SCFG regarding flash operations
				set scfg_data [handle_permissions_in_ccfg_or_scfg $scfg_data $scfg_permission_idx \
					$scfg_permission_section_start_idx $scfg_permission_cfg_len $scfg_permission_crc_idx "flash"]
                set scfg_crc [format "0x%08X" [calculate_crc $scfg_data 0xe4]]
                set scfg_data_hex [get_data_hex_format $scfg_data]
                handle_blank_device $ccfg_data_hex $ccfg_crc_lst $::_CHIP_NAME_TEMP.dap $::_CHIP_NAME_TEMP $scfg_data_hex $scfg_crc
            } elseif {$::_CHIP_NAME_TEMP == "cc23xx"} {
                # For cc23xx, pass 0x0 for SCFG data and CRC
                handle_blank_device $ccfg_data_hex $ccfg_crc_lst $::_CHIP_NAME_TEMP.dap $::_CHIP_NAME_TEMP 0x0 0x0
            } else {
				return -code error "Error: Invalid device name"
			}
        } else {
            perform_reset_halt $::_CHIP_NAME_TEMP
            echo "examine-start"
        }
    }
}
