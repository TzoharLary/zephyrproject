# תוכנית אב: הקמת תשתית בדיקות פרופילים וירטואלית (Virtual Profile Compliance - VPC)

המטרה של התוכנית הזו היא ליצור **"מכונת בדיקות וירטואלית"** שתחליף את הצורך ב-PTS פיזי עבור בדיקות פונקציונליות של פרופילים, תוך שימוש בתשתית Zephyr הקיימת, כלי סימולציה (Renode), וספריית בדיקות פייתון (Bumble/AutoPTS) — כל זאת עם **מינימום שינויים בקוד הליבה של הפרויקט**.

---

## חזון ומטרה
יצירת מערכת בדיקות אוטומטית מלאה (End-to-End) שרצה כולה על מחשב המפתח (Linux), ללא תלות בחומרה פיזית (ללא לוחות TI וללא דונגל PTS). המערכת תוודא שמימושי הפרופילים ב-Zephyr תואמים לתקן ה-Bluetooth ומגיבים נכון לתרחישי קצה, בצורה השקולה לוגית לבדיקות ה-PTS הרשמיות.

## עקרונות מנחים (Design Principles)
1. **Non-Intrusive (ללא פגיעה בקוד קיים):** כל הטסטים, הסקריפטים והקונפיגורציות יישבו בתיקיית בדיקות נפרדת (`tests/vpc`) או כ-Overlay חיצוני, מבלי לשנות את קוד המקור של Zephyr או AutoPTS.
2. **Hardware Agnostic Logic:** הבדיקה תוודא את הלוגיקה של הפרופיל (Host Stack) כשהיא רצה על סימולציה של חומרת TI, אך תהיה מנותקת מה-PHY (רדיו) הפיזי הבעייתי לסימולציה.
3. **Reuse over Rewrite:** שימוש מקסימלי בטסטים קיימים מהקהילה (Bumble/BlueZ/Zephyr Samples) במקום כתיבת לוגיקה מאפס.

---

## שלב 1: הקמת תשתית הסימולציה וה-Bridge (ה"צנרת")
**מטרה:** לאפשר לקוד שרץ בתוך "העולם הוירטואלי" (Renode) לדבר עם סקריפט בדיקה ב"עולם החיצון" (המחשב שלך).

**היגיון:** מאחר ואין סימולטור רדיו (RF-PHY) אמין ל-TI כמו BabbleSim, אנו נעקוף את הרדיו. נגדיר ל-Zephyr "לדבר" דרך UART במקום דרך האנטנה, ונחבר את ה-UART הזה ל-Socket במחשב.

**פעולות לביצוע:**
1. **יצירת `boards/vpc_overlay.conf`:** קובץ קונפיגורציה ייעודי לבדיקות שלא משנה את הלוח המקורי. הקובץ יכיל:
   - `CONFIG_BT_CTLR=n`: ביטול ה-Controller הפיזי של TI (שאינו נתמך בסימולציה).
   - `CONFIG_BT_HCI=y`: הפעלת ממשק HCI סטנדרטי.
   - `CONFIG_BT_H4=y`: הגדרת פרוטוקול H4 מעל UART.
2. **כתיבת סקריפט `ti_renode_bridge.resc`:** סקריפט הרצה ל-Renode שיבצע:
   - טעינת המכונה (למשל `cc1352r1_launchxl`).
   - `emulation CreateServerSocketTerminal 3456 "ble_hci"`: יצירת שרת TCP בפורט 3456.
   - `connector Connect sysbus.uart0 ble_hci`: חיבור ה-UART של המעבד לשרת ה-TCP.
3. **בדיקת היתכנות (Sanity):** בניית אפליקציית `samples/bluetooth/hci_uart` עם ה-Overlay, הרצה ב-Renode, ושימוש בכלי `btmon` או `bumble-hci-bridge` במחשב כדי לראות "דופק" (HCI Reset Command).

## שלב 2: בניית ה-DUT הגנרי (Device Under Test)
**מטרה:** יצירת אפליקציית Zephyr אחת שתכיל את *כל* הפרופילים שאנו רוצים לבדוק, נשלטת על ידי קונפיגורציה.

**היגיון:** במקום לבנות 9 אפליקציות שונות, נבנה אפליקציה אחת מודולרית. זה חוסך זמני בנייה ומונע שכפול קוד.

**פעולות לביצוע:**
1. **יצירת `tests/vpc/src/main.c`:**
   - קוד שמאתחל את ה-Bluetooth Stack.
   - רישום כל השירותים (DIS, BAS, HRS וכו') אך עטיפתם ב-`#ifdef CONFIG_BT_DIS`, `#ifdef CONFIG_BT_BAS` וכו'.
2. **יצירת `tests/vpc/prj.conf`:** קובץ בסיס שמכיל את ההגדרות המשותפות לכולם.
3. **מימוש הפרופילים החסרים (BPS, WSS, ANCS, AMS, ScPS):**
   - במקום לכתוב הכל ב-`main.c`, צור תיקייה `profiles/`.
   - עבור כל פרופיל חסר, צור קובץ `.c` ו-`.h` שמממש את ה-GATT Service ואת הלוגיקה הבסיסית (למשל: עבור BPS, פונקציה שמעדכנת מדידת לחץ דם דמי).
   - **הערה חשובה:** עבור ANCS ו-AMS (פרופילים של אפל), המימוש הוא בצד ה-Client (ה-DUT צורך מידע). המימוש יכלול רישום ל-GATT Client.

## שלב 3: הקמת ה"בודק" (The Tester) - תחליף ה-PTS
**מטרה:** יצירת סקריפטים חיצוניים (Python) שידברו עם ה-DUT דרך ה-Socket ויבצעו את הבדיקות.

**היגיון:** שימוש בספריית **Bumble** של גוגל. היא כתובה בפייתון, תומכת בחיבור HCI-over-Socket, ומכילה כבר מימושים של פרופילים רבים. זהו המנוע ש"מחקה" את ה-PTS.

**פעולות לביצוע:**
1. **התקנת Bumble:** `pip install bumble`.
2. **יצירת תשתית בדיקה בפייתון (`tests/vpc/pytest/`):**
   - יצירת `conftest.py`: קובץ הגדרות ל-Pytest שיטפל בחיבור ל-Renode (פתיחת ה-Socket והעברתו ל-Bumble Device).
3. **כתיבת מחלקת בסיס (`BumbleTester`):** מחלקה שתירש מ-Bumble Device ותספק פונקציות עזר כמו `connect_to_device()`, `discover_services()`, `read_characteristic()`.

## שלב 4: הטמעת בדיקות לפרופילים קיימים (Quick Wins)
**מטרה:** וידוא שהמערכת עובדת עם פרופילים שכבר ממומשים היטב ב-Zephyr (DIS, BAS, HRS, HID).

**פעולות לביצוע (רדוקציה):**
1. **DIS:** העתק את הלוגיקה מ-`bumble/examples/device_information_client.py`. התאם אותה לרוץ כפונקציית Pytest. הבדיקה תוודא שניתן לקרוא את `Manufacturer Name`.
2. **BAS:** שימוש בלקוח Battery Service של Bumble. וודא שקריאה מחזירה ערך סוללה וששינוי ב-DUT שולח Notification.
3. **שילוב ב-Twister:** יצירת קובץ `testcase.yaml` בתיקייה.
   - הגדרת `harness: pytest`.
   - הגדרת `platform_allow: cc1352r1_launchxl` (או כל לוח TI אחר).
   - הוספת דגל `extra_args: DTC_OVERLAY_FILE="boards/vpc_overlay.conf"` כדי להזריק את תצורת הסימולציה.

## שלב 5: פיתוח בדיקות לפרופילים החסרים (The Heavy Lifting)
**מטרה:** כתיבת סקריפטי בדיקה עבור BPS, WSS, ANCS, AMS, ScPS.

**היגיון:** כאן תתבצע העבודה העיקרית. עבור הפרופילים הסטנדרטיים (BPS, WSS, ScPS), נכתוב סקריפט Bumble שמתנהג כ-GATT Client. עבור הפרופילים של אפל (ANCS, AMS), נכתוב סקריפט שמתנהג כ-**GATT Server** (מדמה אייפון) ומחכה שה-DUT יתחבר אליו.

**פעולות לביצוע:**
1. **BPS/WSS/ScPS:** כתוב סקריפט שמתחבר, מוצא את השירות לפי ה-UUID, ומבצע את רצף הפעולות המוגדר ב-Spec (למשל: Enable Indications -> Wait for Measurement).
2. **ANCS/AMS (האתגר הגדול):**
   - בסקריפט Bumble, הגדר שרת שמפרסם את ה-UUIDs של אפל (7905F431-...).
   - הסקריפט יחכה שה-DUT יבצע Discovery וינסה לכתוב ל-Control Point.
   - הבדיקה תעבור אם ה-DUT ביצע את רצף הפקודות הנכון (למשל, ביקש לקבל נוטיפיקציות על שיחות נכנסות).

## שלב 6: אינטגרציה מלאה עם Twister (The Orchestration)
**מטרה:** הרצת פקודה אחת (`west twister`) שמבצעת את כל הקסם: בונה את ה-C, מריצה את Renode, מריצה את הפייתון, ומדווחת תוצאות.

**היגיון:** Twister יודע לנהל בדיקות Pytest. נגדיר לו ש-Renode הוא "החומרה".

**פעולות לביצוע:**
1. **עדכון `testcase.yaml`:**

   ```yaml
   tests:
     vpc.profiles.dis:
       extra_configs:
         - CONFIG_BT_DIS=y
       harness: pytest
       harness_config:
         pytest_root: tests/vpc/pytest/dis_test.py
   ```

2. **הגדרת Renode כ-Fixture:** בתוך קוד ה-Pytest, נשתמש בפיקצ'ר שיריץ את Renode ברקע לפני תחילת הטסט ויהרוג אותו בסיום.

## שלב 7: הריצה הסופית וניתוח תוצאות
**מטרה:** קבלת דו"ח ירוק/אדום שקול ל-PTS.

**פעולות לביצוע:**
1. הרצת הפקודה: `west twister -T tests/vpc -p cc1352r1_launchxl --enable-slow`.
2. **ניתוח:** אם בדיקה נכשלת, Twister ישמור את הלוגים של Renode (מה קרה בתוך המעבד) ואת הלוגים של Bumble (מה קרה בפרוטוקול). זה נותן יכולת דיבוג עמוקה יותר מ-PTS (שהוא קופסה שחורה).

---

## סיכום היתרונות של תוכנית זו
1. **עצמאות מחומרה:** ניתן להריץ ב-CI/CD בגיטהאב ללא דונגלים.
2. **כיסוי מלא:** בודק גם את צד ה-GATT של ה-DUT וגם את הלוגיקה העסקית.
3. **אפס שינויים בקוד מקור:** הכל יושב בתיקיית `tests/` נפרדת ומשתמש ב-Overlays.
4. **שקילות ל-PTS:** הסקריפטים ב-Bumble יממשו בדיוק את אותם צעדים שמוגדרים ב-Test Spec של ה-Bluetooth SIG.
